diff --git a/libs/pigment/KoColorConversions.cpp b/libs/pigment/KoColorConversions.cpp
index 0a00c33..a0c6133 100644
--- a/libs/pigment/KoColorConversions.cpp
+++ b/libs/pigment/KoColorConversions.cpp
@@ -232,6 +232,100 @@ void HSVToRGB(float h, float s, float v, float *r, float *g, float *b)
     }
 }

+
+void RGBToHCG(qreal r, qreal g, qreal b, qreal *h, qreal *c, qreal *hcgG)
+{
+    qreal max = qMax(r, qMax(g, b));
+    qreal min = qMin(r, qMin(g, b));
+
+    *c = (max - min);
+
+    if (*c <= 1 - EPSILON) {
+        *hcgG = min / (1 - *c);
+    } else {
+        *hcgG = 0;
+    }
+
+    if (*c < EPSILON) {
+        *h = UNDEFINED_HUE;
+    } else {
+        if (r == max) {
+            *h = (g - b) / *c;
+        } else if (g == max) {
+            *h = 2 + (b - r) / *c;
+        } else {
+            *h = 4 + (r - g) / *c;
+        }
+
+        *h *= 60;
+        if (*h < 0) {
+            *h += 360;
+        }
+    }
+    //*h /= 360.0;
+}
+
+void HCGToRGB(qreal h, qreal c, qreal hcgG, qreal *r, qreal *g, qreal *b)
+{
+    if (c < EPSILON || h == UNDEFINED_HUE) {
+        // Achromatic case
+
+        *r = hcgG;
+        *g = hcgG;
+        *b = hcgG;
+    } else {
+        qreal f, p, q, t, v;
+        int i;
+
+        if (h > 360 - EPSILON) {
+            h -= 360;
+        }
+
+        h /= 60;
+        i = static_cast<int>(floor(h));
+        f = h - i;
+        p = hcgG * (1 - c);
+        v = c + p;
+        t = f * c + p;
+        q = (1 - f) * c + p;
+
+        switch (i) {
+        case 0:
+            *r = v;
+            *g = t;
+            *b = p;
+            break;
+        case 1:
+            *r = q;
+            *g = v;
+            *b = p;
+            break;
+        case 2:
+            *r = p;
+            *g = v;
+            *b = t;
+            break;
+        case 3:
+            *r = p;
+            *g = q;
+            *b = v;
+            break;
+        case 4:
+            *r = t;
+            *g = p;
+            *b = v;
+            break;
+        case 5:
+            *r = v;
+            *g = p;
+            *b = q;
+            break;
+        }
+    }
+}
+
+
+
 void rgb_to_hls(quint8 red, quint8 green, quint8 blue, float * hue, float * lightness, float * saturation)
 {
     float r = red / 255.0;
@@ -444,7 +538,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
     //if (y>1.0){luma=1.0;}
     if (y<0.0){luma=0.0;}
     else {luma=y;}
-
+
     qreal segment = 0.166667;//1/6;
     qreal r=0.0;
     qreal g=0.0;
@@ -460,7 +554,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
             //need to treat this as a weighted hsl thingy.
             //so first things first, at which luma is the maximum saturation for this hue?
             //between R and G+R (yellow)
-        max_sat = R + ( G*(hue*6) );
+        max_sat = R + ( G*(hue*6) );
         if (luma<=max_sat){luma_a = (luma/max_sat)*0.5; chroma=sat*2*luma_a;}
         else {luma_a = ((luma-max_sat)/(1-max_sat)*0.5)+0.5; chroma=sat*(2-2*luma_a);}

@@ -485,7 +579,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
         r += m; g += m; b += m;
     } else if (hue >= (2.0*segment) && hue < (3.0*segment) ) {
         max_sat = G + (B*(hue-2.0*segment)*6);
-        if (luma<max_sat) {
+        if (luma<max_sat) {
             luma_a = (luma/max_sat)*0.5; chroma=sat*(2*luma_a);
         } else {
             luma_a = ((luma-max_sat)/(1-max_sat)*0.5)+0.5; chroma=sat*(2-2*luma_a);
@@ -496,7 +590,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
         m = luma-( (R*r)+(B*b)+(G*g) );
         r += m; g += m; b += m;
     } else if (hue >= (3.0*segment) && hue < (4.0*segment) ) {
-        max_sat = (G+B) - (G*(hue-3.0*segment)*6);
+        max_sat = (G+B) - (G*(hue-3.0*segment)*6);
         if (luma<max_sat){
             luma_a = (luma/max_sat)*0.5; chroma=sat*(2*luma_a);
         } else {
@@ -509,7 +603,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
         m = luma-( (R*r)+(B*b)+(G*g) );
         r += m; g += m; b += m;
     } else if (hue >= (4.0*segment) && hue < (5*segment) ) {
-        max_sat = B + (R*((hue-4.0*segment)*6));
+        max_sat = B + (R*((hue-4.0*segment)*6));
         if (luma<max_sat) {
             luma_a = (luma/max_sat)*0.5; chroma=sat*(2*luma_a);
         } else {
@@ -521,7 +615,7 @@ void HSYToRGB(const qreal h,const qreal s, const qreal y, qreal *red, qreal *gre
         m = luma-( (R*r)+(B*b)+(G*g) );
         r += m; g += m; b += m;
     } else if (hue >= (5.0*segment) && hue <= 1.0) {
-        max_sat = (B+R) - (B*(hue-5.0*segment)*6);
+        max_sat = (B+R) - (B*(hue-5.0*segment)*6);
         if (luma<max_sat){
             luma_a = (luma/max_sat)*0.5; chroma=sat*(2*luma_a);
         } else {
@@ -629,7 +723,7 @@ void RGBToHSY(const qreal r,const qreal g,const qreal b, qreal *h, qreal *s, qre
         } else{
             luma_a = ((luma-max_sat)/(1-max_sat)*0.5)+0.5;
         }
-
+
         if (chroma > 0.0) {
             sat = (luma <= max_sat) ? (chroma/ (2*luma_a) ) :(chroma/(2.0-(2*luma_a) ) ) ;
         }
@@ -646,7 +740,7 @@ void RGBToHSY(const qreal r,const qreal g,const qreal b, qreal *h, qreal *s, qre


 }
-//Extra: Functions for converting from and back to HCI. Where the HSI function is forced cylindrical, HCI is a
+//Extra: Functions for converting from and back to HCI. Where the HSI function is forced cylindrical, HCI is a
 //double cone. This is for compatibility purposes, and of course, making future programmers who expect a double-cone
 // function less sad. These algorithms were taken from wikipedia.

@@ -656,7 +750,7 @@ void HCIToRGB(const qreal h, const qreal c, const qreal i, qreal *red, qreal *gr
 //to the weighted HCY, but assuming that the weights are the same(one-third).
     qreal hue=0.0;
     qreal chroma=0.0;
-    qreal intensity=0.0;
+    qreal intensity=0.0;
     if(i<0.0){intensity = 0.0;} else{intensity = i;}
     if (h>1.0 || h<0.0){hue=fmod(h, 1.0);} else {hue=h;}
     if(c<0.0){chroma = 0.0;} else{chroma = c;}
@@ -664,7 +758,7 @@ void HCIToRGB(const qreal h, const qreal c, const qreal i, qreal *red, qreal *gr
     qreal r=0.0;
     qreal g=0.0;
     qreal b=0.0;
-
+
     int fract = static_cast<int>(hue*6.0);
     qreal x = (1-fabs(fmod(hue*6.0,2)-1) )*chroma;
     switch (fract) {
@@ -731,7 +825,7 @@ void HCYToRGB(const qreal h, const qreal c, const qreal y, qreal *red, qreal *gr
     qreal g=0.0;
     qreal b=0.0;

-    int fract =static_cast<int>(hue*6.0);
+    int fract =static_cast<int>(hue*6.0);
     qreal x = (1-fabs(fmod(hue*6.0,2)-1) )*chroma;
     switch (fract) {
         case 0:r = chroma; g=x; b=0;break;
@@ -827,7 +921,7 @@ void LabToLCH(const qreal l, const qreal a, const qreal b, qreal *L, qreal *C, q
     *L=qBound(0.0,l,1.0);
     *C=sqrt( pow(atemp,2.0) + pow(btemp,2.0) )*0.1;
     qreal hue = (atan2(btemp,atemp))* 180.0 / M_PI;
-
+
     if (hue<0.0) {
         hue+=360.0;
     } else {
@@ -853,7 +947,7 @@ void XYZToxyY(const qreal X, const qreal Y, const qreal Z, qreal *x, qreal *y, q
     *x=X/(X+Y+Z);
     *y=Y/(X+Y+Z);
     *yY=Y;
-}
+}
 void xyYToXYZ(const qreal x, const qreal y, const qreal yY, qreal *X, qreal *Y, qreal *Z)
 {
     qBound(0.0,x,1.0);
@@ -873,7 +967,7 @@ void CMYToCMYK(qreal *c, qreal *m, qreal *y, qreal *k)
     if ( cyan    < key ) {key = cyan;}
     if ( magenta < key ) {key = magenta;}
     if ( yellow  < key ) {key = yellow;}
-
+
     if ( key == 1 ) { //Black
         cyan    = 0;
         magenta = 0;
@@ -884,7 +978,7 @@ void CMYToCMYK(qreal *c, qreal *m, qreal *y, qreal *k)
         magenta = ( magenta - key ) / ( 1.0 - key );
         yellow  = ( yellow  - key ) / ( 1.0 - key );
     }
-
+
     *c=qBound(0.0,cyan   ,1.0);
     *m=qBound(0.0,magenta,1.0);
     *y=qBound(0.0,yellow ,1.0);
@@ -898,11 +992,11 @@ void CMYKToCMY(qreal *c, qreal *m, qreal *y, qreal *k)
     qreal cyan    = *c;
     qreal magenta = *m;
     qreal yellow  = *y;
-
+
     cyan    = ( cyan    * ( 1.0 - key ) + key );
     magenta = ( magenta * ( 1.0 - key ) + key );
     yellow  = ( yellow  * ( 1.0 - key ) + key );
-
+
     *c=qBound(0.0,cyan   ,1.0);
     *m=qBound(0.0,magenta,1.0);
     *y=qBound(0.0,yellow ,1.0);
diff --git a/libs/pigment/KoColorConversions.h b/libs/pigment/KoColorConversions.h
index 852ed40..1bbae23 100644
--- a/libs/pigment/KoColorConversions.h
+++ b/libs/pigment/KoColorConversions.h
@@ -34,6 +34,9 @@ KRITAPIGMENT_EXPORT void hsv_to_rgb(int H, int S, int V, int *R, int *G, int *B)
 KRITAPIGMENT_EXPORT void RGBToHSV(float r, float g, float b, float *h, float *s, float *v);
 KRITAPIGMENT_EXPORT void HSVToRGB(float h, float s, float v, float *r, float *g, float *b);

+KRITAPIGMENT_EXPORT void RGBToHCG(qreal r, qreal g, qreal b, qreal *h, qreal *c, qreal *hcgG);
+KRITAPIGMENT_EXPORT void HCGToRGB(qreal h, qreal c, qreal hcgG, qreal *r, qreal *g, qreal *b);
+
 KRITAPIGMENT_EXPORT void RGBToHSL(float r, float g, float b, float *h, float *s, float *l);
 KRITAPIGMENT_EXPORT void HSLToRGB(float h, float sl, float l, float *r, float *g, float *b);

diff --git a/libs/ui/canvas/kis_display_color_converter.cpp b/libs/ui/canvas/kis_display_color_converter.cpp
index 5fd4b32..39d27d5 100644
--- a/libs/ui/canvas/kis_display_color_converter.cpp
+++ b/libs/ui/canvas/kis_display_color_converter.cpp
@@ -580,6 +580,30 @@ void KisDisplayColorConverter::getHslF(const KoColor &srcColor, qreal *h, qreal
     color.getHslF(h, s, l, a);
 }

+KoColor KisDisplayColorConverter::fromHcgF(qreal h, qreal c, qreal hcgG)
+{
+    // generate HSI from sRGB!
+    qreal r=0.0;
+    qreal g=0.0;
+    qreal b=0.0;
+    qreal a=1.0;
+    HCGToRGB(h * 360.0, c, hcgG, &r, &g, &b);
+    QColor qcolor;
+    qcolor.setRgbF(qBound(0.0,r,1.0), qBound(0.0,g,1.0), qBound(0.0,b,1.0), a);
+    return m_d->approximateFromQColor(qcolor);
+}
+
+void KisDisplayColorConverter::getHcgF(const KoColor &srcColor, qreal *h, qreal *c, qreal *hcgG)
+{
+    // we are going through sRGB here!
+    QColor color = m_d->approximateToQColor(srcColor);
+    qreal r=color.redF();
+    qreal g=color.greenF();
+    qreal b=color.blueF();
+    RGBToHCG(r, g, b, h, c, hcgG);
+    *h /= 360.0;
+}
+
 KoColor KisDisplayColorConverter::fromHsiF(qreal h, qreal s, qreal i)
 {
     // generate HSI from sRGB!
diff --git a/libs/ui/canvas/kis_display_color_converter.h b/libs/ui/canvas/kis_display_color_converter.h
index 2c6d44d..6f47b51 100644
--- a/libs/ui/canvas/kis_display_color_converter.h
+++ b/libs/ui/canvas/kis_display_color_converter.h
@@ -76,12 +76,14 @@ public:
     KoColor fromHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);
     KoColor fromHslF(qreal h, qreal s, qreal l, qreal a = 1.0);
 	KoColor fromHsiF(qreal h, qreal s, qreal i);
+    KoColor fromHcgF(qreal h, qreal c, qreal hcgG);
     KoColor fromHsyF(qreal h, qreal s, qreal y, qreal R=0.2126, qreal G=0.7152, qreal B=0.0722, qreal gamma=2.2);

     void getHsv(const KoColor &srcColor, int *h, int *s, int *v, int *a = 0) const;
     void getHsvF(const KoColor &srcColor, qreal *h, qreal *s, qreal *v, qreal *a = 0);
     void getHslF(const KoColor &srcColor, qreal *h, qreal *s, qreal *l, qreal *a = 0);
 	void getHsiF(const KoColor &srcColor, qreal *h, qreal *s, qreal *i);
+    void getHcgF(const KoColor &srcColor, qreal *h, qreal *c, qreal *hcgG);
     void getHsyF(const KoColor &srcColor, qreal *h, qreal *s, qreal *y, qreal R=0.2126, qreal G=0.7152, qreal B=0.0722, qreal gamma=2.2);

     static KoColorConversionTransformation::Intent renderingIntent();
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector.cpp
index fc0b2b5..bfe4515 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector.cpp
@@ -123,14 +123,14 @@ void KisColorSelector::setConfiguration(Configuration conf)
         Q_ASSERT(false);
     }

-    connect(m_mainComponent, SIGNAL(paramChanged(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)),
-            m_subComponent,  SLOT(setParam(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)), Qt::UniqueConnection);
-    connect(m_subComponent,  SIGNAL(paramChanged(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)),
-            m_mainComponent, SLOT(setParam(qreal,qreal,qreal,qreal, qreal, qreal, qreal, qreal, qreal)), Qt::UniqueConnection);
+    connect(m_mainComponent, SIGNAL(paramChanged(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)),
+            m_subComponent,  SLOT(setParam(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)), Qt::UniqueConnection);
+    connect(m_subComponent,  SIGNAL(paramChanged(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)),
+            m_mainComponent, SLOT(setParam(qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal,qreal)), Qt::UniqueConnection);

     connect(m_mainComponent, SIGNAL(update()), m_signalCompressor, SLOT(start()), Qt::UniqueConnection);
     connect(m_subComponent,  SIGNAL(update()), m_signalCompressor, SLOT(start()), Qt::UniqueConnection);
-
+
     m_mainComponent->setConfiguration(m_configuration.mainTypeParameter, m_configuration.mainType);
     m_subComponent->setConfiguration(m_configuration.subTypeParameter, m_configuration.subType);

diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector.h b/plugins/dockers/advancedcolorselector/kis_color_selector.h
index f9cf0f6..0810721 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector.h
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector.h
@@ -32,7 +32,7 @@ class KisColorSelector : public KisColorSelectorBase
     Q_OBJECT
 public:
     enum Type {Ring, Square, Wheel, Triangle, Slider};
-    enum Parameters {H, hsvS, V, hslS, L, SL, SV, SV2, hsvSH, hslSH, VH, LH, SI, SY, hsiSH, hsySH, I, Y, IH, YH, hsiS, hsyS};
+    enum Parameters {H, hsvS, V, hslS, L, SL, SV, SV2, hsvSH, hslSH, VH, LH, SI, SY, hsiSH, hsySH, I, Y, IH, YH, hsiS, hsyS, hcgCG, hcgCH, hcgG, hcgGH, hcgC};
     struct Configuration {
         Type mainType;
         Type subType;
@@ -66,7 +66,7 @@ public:
             int imtp=strili.at(2).toInt();
             int istp=strili.at(3).toInt();

-            if(imt>Slider || ist>Slider || imtp>hsyS || istp>hsyS)//this was LH before
+            if(imt>Slider || ist>Slider /*|| imtp>hsyS || istp>hsyS*/)//this was LH before
                 return;

             mainType = Type(imt);
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_combo_box.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_combo_box.cpp
index 1fe1997..58b586d 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_combo_box.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_combo_box.cpp
@@ -40,8 +40,8 @@ public:
         layout->setSpacing(spacing);

         //dbgKrita<<"Created list";
-
-        layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Triangle, KisColorSelector::Ring, KisColorSelector::SL , KisColorSelector::H), this), 0,0);
+
+        layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Triangle, KisColorSelector::Ring, KisColorSelector::SL , KisColorSelector::H), this), 0,0);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   KisColorSelector::Ring, KisColorSelector::SV , KisColorSelector::H), this), 0,1);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   KisColorSelector::Ring, KisColorSelector::SV2, KisColorSelector::H), this), 0,2);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::VH, KisColorSelector::hsvS), this), 0,3);
@@ -50,8 +50,8 @@ public:
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::SV, KisColorSelector::H), this), 1,1);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::VH, KisColorSelector::hsvS), this), 1,2);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hsvSH, KisColorSelector::V), this), 1,3);
-
-
+
+

         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   KisColorSelector::Ring, KisColorSelector::SL , KisColorSelector::H), this), 0,1);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::LH, KisColorSelector::hslS), this), 0,2);
@@ -59,21 +59,28 @@ public:
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::SL, KisColorSelector::H), this), 1,0);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::LH, KisColorSelector::hslS), this), 1,1);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hslSH, KisColorSelector::L), this), 1,2);
-
-
+
+
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   	KisColorSelector::Ring, KisColorSelector::SI , KisColorSelector::H), this), 0,1);
         layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::IH, KisColorSelector::hsiS), this), 0,2);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::hsiSH, KisColorSelector::I), this), 0,3);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::SI, KisColorSelector::H), this), 1,0);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::IH, KisColorSelector::hsiS), this), 1,1);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hsiSH, KisColorSelector::I), this), 1,2);
-
+
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   KisColorSelector::Ring, KisColorSelector::SY , KisColorSelector::H), this), 0,1);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::YH, KisColorSelector::hsyS), this), 0,2);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::hsySH, KisColorSelector::Y), this), 0,3);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::SY, KisColorSelector::H), this), 1,0);
 	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::YH, KisColorSelector::hsyS), this), 1,1);
-	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hsySH, KisColorSelector::Y), this), 1,2);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hsySH, KisColorSelector::Y), this), 1,2);
+
+        layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square,   KisColorSelector::Ring, KisColorSelector::hcgCG , KisColorSelector::H), this), 0,1);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::hcgGH, KisColorSelector::hcgC), this), 0,2);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Wheel, KisColorSelector::Slider, KisColorSelector::hcgCH, KisColorSelector::hcgG), this), 0,3);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hcgCG, KisColorSelector::H), this), 1,0);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hcgGH, KisColorSelector::hcgC), this), 1,1);
+	    layout->addWidget(new KisColorSelector(KisColorSelector::Configuration(KisColorSelector::Square, KisColorSelector::Slider, KisColorSelector::hcgCH, KisColorSelector::hcgG), this), 1,2);

         setList(0);

@@ -90,7 +97,7 @@ public:
             }
         }

-
+
     }


@@ -98,30 +105,36 @@ public:
             for(int i=1; i<layout()->count(); i++) {
         layout()->itemAt(i)->widget()->hide();
         }
-
+
         if  (model==0){
             for(int i=1; i<9; i++) {
             layout()->itemAt(i)->widget()->show();
             }
         }
-
+
         if  (model==1){
             for(int i=9; i<15; i++) {
             layout()->itemAt(i)->widget()->show();
             }
         }
-
+
         if  (model==2){
             for(int i=15; i<21; i++) {
             layout()->itemAt(i)->widget()->show();
             }
         }
-
+
         if  (model==3){
-            for(int i=21; i<layout()->count(); i++) {
+            for(int i=21; i<27; i++) {
             layout()->itemAt(i)->widget()->show();
             }
-        }
+        }
+
+        if  (model==4){
+            for(int i=27; i<33; i++) {
+            layout()->itemAt(i)->widget()->show();
+            }
+        }
     }
 protected:
     void paintEvent(QPaintEvent *)
@@ -135,10 +148,10 @@ protected:
     {
         if(rect().contains(e->pos())) {
             for(int i=0; i<layout()->count(); i++) {
-
+
                 KisColorSelector* item = dynamic_cast<KisColorSelector*>(layout()->itemAt(i)->widget());
                 Q_ASSERT(item);
-
+

                 if(layout()->itemAt(i)->widget()->isVisible()==true && item->geometry().adjusted(-spacing/2, -spacing/2, spacing/2, spacing/2).contains(e->pos())) {
                     QRect oldArea=highlightArea;
@@ -238,5 +251,5 @@ void KisColorSelectorComboBox::setConfiguration(KisColorSelector::Configuration

 void KisColorSelectorComboBox::setList(int model) {

-    m_private->setList(model);
+    m_private->setList(model);
 }
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_component.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_component.cpp
index 24feaf9..58797f0 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_component.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_component.cpp
@@ -35,6 +35,8 @@ KisColorSelectorComponent::KisColorSelectorComponent(KisColorSelector* parent) :
     m_intensity(0.333),
     m_hsySaturation(1),
     m_luma(0.299),
+    m_hcgChroma(1),
+    m_gray(1),
     m_parent(parent),
     m_width(0),
     m_height(0),
@@ -108,7 +110,19 @@ KoColor KisColorSelectorComponent::currentColor()
     return selectColor(m_lastX, m_lastY);
 }

-void KisColorSelectorComponent::setParam(qreal hue, qreal hsvSaturation, qreal value, qreal hslSaturation, qreal lightness, qreal hsiSaturation, qreal intensity, qreal hsySaturation, qreal luma)
+void KisColorSelectorComponent::setParam(
+    qreal hue,
+    qreal hsvSaturation,
+    qreal value,
+    qreal hslSaturation,
+    qreal lightness,
+    qreal hsiSaturation,
+    qreal intensity,
+    qreal hsySaturation,
+    qreal luma,
+    qreal hcgChroma,
+    qreal gray
+)
 {
     if(qFuzzyCompare(m_hue, hue) &&
        qFuzzyCompare(m_hsvSaturation, hsvSaturation) &&
@@ -118,7 +132,9 @@ void KisColorSelectorComponent::setParam(qreal hue, qreal hsvSaturation, qreal v
        qFuzzyCompare(m_hsiSaturation, hsiSaturation) &&
        qFuzzyCompare(m_intensity, intensity) &&
        qFuzzyCompare(m_hsySaturation, hsySaturation) &&
-       qFuzzyCompare(m_luma, luma))
+       qFuzzyCompare(m_luma, luma) &&
+       qFuzzyCompare(m_hcgChroma, hcgChroma) &&
+       qFuzzyCompare(m_gray, gray))
         return;

     if(hue>=0. && hue<=1.)
@@ -127,58 +143,74 @@ void KisColorSelectorComponent::setParam(qreal hue, qreal hsvSaturation, qreal v
     if(hsvSaturation>=0. && hsvSaturation<=1.) {
         m_hsvSaturation=hsvSaturation;
         m_hslSaturation=-1;
-	m_hsiSaturation=-1;
-	m_hsySaturation=-1;
+        m_hsiSaturation=-1;
+        m_hsySaturation=-1;
+        m_hcgChroma=-1;
     }
-
-    if(value>=0. && value<=1.) {
-        m_value=value;
-        m_intensity=-1;
-	m_luma=-1;
-	m_lightness=-1;
-    }
-
     if(hslSaturation>=0. && hslSaturation<=1.) {
         m_hslSaturation=hslSaturation;
         m_hsvSaturation=-1;
-	m_hsiSaturation=-1;
-	m_hsySaturation=-1;
-    }
-
-    if(lightness>=0. && lightness<=1.) {
-        m_lightness=lightness;
-        m_value=-1;
-	m_luma=-1;
-	m_intensity=-1;
+        m_hsiSaturation=-1;
+        m_hsySaturation=-1;
+        m_hcgChroma=-1;
     }
     if(hsiSaturation>=0. && hsiSaturation<=1.) {
         m_hsiSaturation=hsiSaturation;
         m_hsvSaturation=-1;
-	m_hslSaturation=-1;
-	m_hsySaturation=-1;
-    }
-
-    if(intensity>=0. && intensity<=1.) {
-        m_intensity=intensity;
-        m_value=-1;
-	m_luma=-1;
-	m_lightness=-1;
+        m_hslSaturation=-1;
+        m_hsySaturation=-1;
+        m_hcgChroma=-1;
     }
-
     if(hsySaturation>=0. && hsySaturation<=1.) {
         m_hsySaturation=hsySaturation;
         m_hsvSaturation=-1;
-	m_hsiSaturation=-1;
-	m_hslSaturation=-1;
+        m_hsiSaturation=-1;
+        m_hslSaturation=-1;
+        m_hcgChroma=-1;
+    }
+    if(hcgChroma>=0. && hcgChroma<=1.) {
+        m_hsySaturation=-1;
+        m_hsvSaturation=-1;
+        m_hsiSaturation=-1;
+        m_hslSaturation=-1;
+        m_hcgChroma=hcgChroma;
     }

+    if(value>=0. && value<=1.) {
+        m_value=value;
+        m_intensity=-1;
+        m_luma=-1;
+        m_lightness=-1;
+        m_gray=-1;
+    }
+    if(lightness>=0. && lightness<=1.) {
+        m_lightness=lightness;
+        m_value=-1;
+        m_luma=-1;
+        m_intensity=-1;
+        m_gray=-1;
+    }
+    if(intensity>=0. && intensity<=1.) {
+        m_intensity=intensity;
+        m_value=-1;
+        m_luma=-1;
+        m_lightness=-1;
+        m_gray=-1;
+    }
     if(luma>=0. && luma<=1.) {
         m_intensity=-1;
         m_value=-1;
-	m_luma=luma;
-	m_lightness=-1;
+        m_luma=luma;
+        m_lightness=-1;
+        m_gray=-1;
+    }
+    if(gray>=0. && gray<=1.) {
+        m_intensity=-1;
+        m_value=-1;
+        m_luma=-1;
+        m_lightness=-1;
+        m_gray=gray;
     }
-

     m_dirty=true;
     emit update();
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_component.h b/plugins/dockers/advancedcolorselector/kis_color_selector_component.h
index 13e1a3c..6874b6c 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_component.h
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_component.h
@@ -62,12 +62,12 @@ public:
 public Q_SLOTS:
     /// set hue, saturation, value or/and lightness
     /// unused parameters should be set to -1
-    void setParam(qreal hue, qreal hsvSaturation, qreal value, qreal hslSaturation, qreal lightness, qreal hsiSaturation, qreal intensity, qreal hsySaturation, qreal luma);
+    void setParam(qreal hue, qreal hsvSaturation, qreal value, qreal hslSaturation, qreal lightness, qreal hsiSaturation, qreal intensity, qreal hsySaturation, qreal luma, qreal hcgChroma, qreal gray);
 Q_SIGNALS:
     /// request for repaint, for instance, if the hue changes.
     void update();
     /// -1, if unaffected
-    void paramChanged(qreal hue, qreal hsvSaturation, qreal value, qreal hslSaturation, qreal lightness, qreal hsiSaturation, qreal intensity, qreal hsySaturation, qreal luma);
+    void paramChanged(qreal hue, qreal hsvSaturation, qreal value, qreal hslSaturation, qreal lightness, qreal hsiSaturation, qreal intensity, qreal hsySaturation, qreal luma, qreal hcgChroma, qreal gray);
 protected:
     const KoColorSpace* colorSpace() const;
     /// returns true, if ether the colour space, the size or the parameters have changed since the last paint event
@@ -97,6 +97,8 @@ protected:
     qreal m_intensity;
     qreal m_hsySaturation;
     qreal m_luma;
+    qreal m_hcgChroma;
+    qreal m_gray;
     Parameter m_parameter;
     Type m_type;
     KisColorSelector* m_parent;
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_ring.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_ring.cpp
index 94e09bb..e24ac7b 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_ring.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_ring.cpp
@@ -53,10 +53,10 @@ bool KisColorSelectorRing::containsPointInComponentCoords(int x, int y) const
     int innerRadiusSquared = innerRadius();
     outerRadiusSquared*=outerRadiusSquared;
     innerRadiusSquared*=innerRadiusSquared;
-
-
+
+
     Vector2i relativeVector(x-width()/2, y-height()/2);
-
+
     if(relativeVector.squaredNorm() < outerRadiusSquared
        && relativeVector.squaredNorm() > innerRadiusSquared) {
         return true;
@@ -72,13 +72,13 @@ void KisColorSelectorRing::paint(QPainter* painter)
         colorCache();
         paintCache();
     }
-
+
     int size = qMin(width(), height());
     if(m_cachedSize!=size) {
         m_cachedSize=size;
         paintCache();
     }
-
+
     painter->drawImage(width()/2-m_pixelCache.width()/2,
                 height()/2-m_pixelCache.height()/2,
                 m_pixelCache);
@@ -114,7 +114,7 @@ KoColor KisColorSelectorRing::selectColor(int x, int y)
     QPoint ringCoord = QPoint(x, y)-ringMiddle;
     qreal hue = std::atan2(qreal(ringCoord.y()), qreal(ringCoord.x()))+(M_PI);
     hue/=2.*M_PI;
-    emit paramChanged(hue, -1, -1, -1, -1, -1, -1, -1, -1);
+    emit paramChanged(hue, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
     m_lastHue=hue;
     emit update();

@@ -126,7 +126,7 @@ void KisColorSelectorRing::setColor(const KoColor &color)
     qreal h, s, v;
     m_parent->converter()->getHsvF(color, &h, &s, &v);

-    emit paramChanged(h, -1, -1, -1, -1, -1, -1, -1, -1);
+    emit paramChanged(h, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);

     // selector keeps the position on the ring if hue is undefined (when saturation is 0)
     if (!qFuzzyCompare(s, 0.0)) {
@@ -139,9 +139,9 @@ void KisColorSelectorRing::setColor(const KoColor &color)
 void KisColorSelectorRing::paintCache()
 {
     QImage cache(m_cachedSize, m_cachedSize, QImage::Format_ARGB32_Premultiplied);
-
+
     Vector2i center(cache.width()/2., cache.height()/2.);
-
+
     for(int x=0; x<cache.width(); x++) {
         for(int y=0; y<cache.height(); y++) {
             Vector2i currentPoint((float)x, (float)y);
@@ -149,7 +149,7 @@ void KisColorSelectorRing::paintCache()

             qreal currentRadius = relativeVector.squaredNorm();
             currentRadius=sqrt(currentRadius);
-
+
             if(currentRadius < outerRadius()+1
                && currentRadius > innerRadius()-1)
             {
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_settings.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_settings.cpp
index b83218c..c0bfc1e 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_settings.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_settings.cpp
@@ -77,6 +77,7 @@ KisColorSelectorSettings::KisColorSelectorSettings(QWidget *parent) :
     ui->colorSelectorTypeComboBox->addItem(i18n("HSL"));
     ui->colorSelectorTypeComboBox->addItem(i18n("HSI"));
     ui->colorSelectorTypeComboBox->addItem(i18n("HSY'"));
+    ui->colorSelectorTypeComboBox->addItem(i18n("HCG"));
     ui->colorSelectorTypeComboBox->setCurrentIndex(0);
     connect( ui->colorSelectorTypeComboBox, SIGNAL(currentIndexChanged(int)),this, SLOT(changedACSColorSelectorType(int)));
     changedACSColorSelectorType(0); // initialize everything to HSV at the start
@@ -86,6 +87,7 @@ KisColorSelectorSettings::KisColorSelectorSettings(QWidget *parent) :
     ui->ACSshadeSelectorMyPaintColorModelComboBox->addItem(i18n("HSL"));
     ui->ACSshadeSelectorMyPaintColorModelComboBox->addItem(i18n("HSI"));
     ui->ACSshadeSelectorMyPaintColorModelComboBox->addItem(i18n("HSY'"));
+    ui->ACSshadeSelectorMyPaintColorModelComboBox->addItem(i18n("HCG"));
     ui->ACSshadeSelectorMyPaintColorModelComboBox->setCurrentIndex(0);


@@ -219,7 +221,7 @@ void KisColorSelectorSettings::savePreferences() const
     cfg.writeEntry("shadeSelectorUpdateOnLeftClick", ui->shadeSelectorUpdateOnLeftClick->isChecked());
     cfg.writeEntry("shadeSelectorUpdateOnBackground", ui->shadeSelectorUpdateOnBackground->isChecked());
     cfg.writeEntry("hidePopupOnClickCheck", ui->hidePopupOnClickCheck->isChecked());
-
+
     //mypaint model

     int shadeMyPaintComboBoxIndex  = ui->ACSshadeSelectorMyPaintColorModelComboBox->currentIndex();
@@ -229,8 +231,10 @@ void KisColorSelectorSettings::savePreferences() const
         cfg.writeEntry("shadeMyPaintType",   "HSL");
     } else  if (shadeMyPaintComboBoxIndex == 2 ) {
         cfg.writeEntry("shadeMyPaintType",   "HSI");
-    } else {   // HSY
+    } else  if (shadeMyPaintComboBoxIndex == 3 ) {   // HSY
         cfg.writeEntry("shadeMyPaintType",   "HSY");
+    } else {
+        cfg.writeEntry("shadeMyPaintType",   "HCG");
     }


@@ -243,15 +247,15 @@ void KisColorSelectorSettings::savePreferences() const
     //color selector
     KisColorSelectorComboBox* cstw = dynamic_cast<KisColorSelectorComboBox*>(ui->colorSelectorConfiguration);
     cfg.writeEntry("colorSelectorConfiguration", cstw->configuration().toString());
-
+
     cfg.writeEntry("hsxSettingType", ui->colorSelectorTypeComboBox->currentIndex());
-
+
     //luma//
     cfg.writeEntry("lumaR", ui->l_lumaR->value());
     cfg.writeEntry("lumaG", ui->l_lumaG->value());
     cfg.writeEntry("lumaB", ui->l_lumaB->value());
     cfg.writeEntry("gamma", ui->SP_Gamma->value());
-
+
     //slider//
     hsxcfg.writeEntry("hsvH", ui->csl_hsvH->isChecked());
     hsxcfg.writeEntry("hsvS", ui->csl_hsvS->isChecked());
@@ -265,6 +269,9 @@ void KisColorSelectorSettings::savePreferences() const
     hsxcfg.writeEntry("hsyH", ui->csl_hsyH->isChecked());
     hsxcfg.writeEntry("hsyS", ui->csl_hsyS->isChecked());
     hsxcfg.writeEntry("hsyY", ui->csl_hsyY->isChecked());
+    hsxcfg.writeEntry("hcgH", ui->csl_hcgH->isChecked());
+    hsxcfg.writeEntry("hcgC", ui->csl_hcgC->isChecked());
+    hsxcfg.writeEntry("hcgG", ui->csl_hcgG->isChecked());

     //hotkeys//
     hotkeycfg.writeEntry("steps_lightness", ui->sb_lightness->value());
@@ -305,7 +312,7 @@ void KisColorSelectorSettings::changedColorDocker(int index)
         ui->advancedColorSelectorOptions->hide();
         ui->hotKeyOptions->hide();
         ui->colorSliderOptions->show();
-    } else {
+    } else {
        ui->colorSliderOptions->hide();
        ui->advancedColorSelectorOptions->hide();
        ui->hotKeyOptions->show();
@@ -325,10 +332,13 @@ void KisColorSelectorSettings::changedACSColorSelectorType(int index)
     else if (index == 2)     {  // HSI
         ui->ACSTypeDescriptionLabel->setText(i18n("Intensity maps to the sum of rgb components"));
     }
-    else {  // HSY'
+    else if (index == 3)    {  // HSY'
         ui->ACSTypeDescriptionLabel->setText(i18n("Luma(Y') is weighted by its coefficients which are configurable. Default values are set to 'rec 709'."));
         ui->lumaCoefficientGroupbox->setVisible(true);
     }
+    else {
+        ui->ACSTypeDescriptionLabel->setText(i18n("HCG color model test"));
+    }

     ui->colorSelectorConfiguration->update();
     emit hsxchanged(index);
@@ -467,8 +477,10 @@ void KisColorSelectorSettings::loadPreferences()
         ui->ACSshadeSelectorMyPaintColorModelComboBox->setCurrentIndex(1);
     } else  if (shadeMyPaintType == "HSI" ) {
         ui->ACSshadeSelectorMyPaintColorModelComboBox->setCurrentIndex(2);
-    } else {   // HSY
+    } else  if (shadeMyPaintType == "HSY" ) {
         ui->ACSshadeSelectorMyPaintColorModelComboBox->setCurrentIndex(3);
+    } else {   // HCG
+        ui->ACSshadeSelectorMyPaintColorModelComboBox->setCurrentIndex(4);
     }


@@ -487,13 +499,13 @@ void KisColorSelectorSettings::loadPreferences()
     //color selector
     KisColorSelectorComboBox* cstw = dynamic_cast<KisColorSelectorComboBox*>(ui->colorSelectorConfiguration);
     cstw->setConfiguration(KisColorSelector::Configuration::fromString(cfg.readEntry("colorSelectorConfiguration", "3|0|5|0"))); // triangle selector
-
+
     //luma values//
     ui->l_lumaR->setValue(cfg.readEntry("lumaR", 0.2126));
     ui->l_lumaG->setValue(cfg.readEntry("lumaG", 0.7152));
     ui->l_lumaB->setValue(cfg.readEntry("lumaB", 0.0722));
     ui->SP_Gamma->setValue(cfg.readEntry("gamma", 2.2));
-
+
     //color sliders//
     ui->csl_hsvH->setChecked(hsxcfg.readEntry("hsvH", false));
     ui->csl_hsvS->setChecked(hsxcfg.readEntry("hsvS", false));
@@ -507,6 +519,9 @@ void KisColorSelectorSettings::loadPreferences()
     ui->csl_hsyH->setChecked(hsxcfg.readEntry("hsyH", false));
     ui->csl_hsyS->setChecked(hsxcfg.readEntry("hsyS", false));
     ui->csl_hsyY->setChecked(hsxcfg.readEntry("hsyY", false));
+    ui->csl_hcgH->setChecked(hsxcfg.readEntry("hcgH", false));
+    ui->csl_hcgC->setChecked(hsxcfg.readEntry("hcgC", false));
+    ui->csl_hcgG->setChecked(hsxcfg.readEntry("hcgG", false));

     //hotkeys//
     ui->sb_lightness->setValue(hotkeycfg.readEntry("steps_lightness", 10));
@@ -515,7 +530,7 @@ void KisColorSelectorSettings::loadPreferences()
     ui->sb_rg->setValue(hotkeycfg.readEntry("steps_redgreen", 10));
     ui->sb_by->setValue(hotkeycfg.readEntry("steps_blueyellow", 10));

-
+
 }

 void KisColorSelectorSettings::loadDefaultPreferences()
@@ -576,16 +591,16 @@ void KisColorSelectorSettings::loadDefaultPreferences()

     // set advanced color selector to use HSV
     ui->colorSelectorTypeComboBox->setCurrentIndex(0);
-
+
     KisColorSelectorComboBox* cstw = dynamic_cast<KisColorSelectorComboBox*>(ui->colorSelectorConfiguration);
     cstw->setConfiguration(KisColorSelector::Configuration("3|0|5|0")); // triangle selector
-
+
     //luma//
     ui->l_lumaR->setValue(0.2126);
     ui->l_lumaG->setValue(0.7152);
     ui->l_lumaB->setValue(0.0722);
     ui->SP_Gamma->setValue(2.2);
-
+
     //color sliders//
     ui->csl_hsvH->setChecked(false);
     ui->csl_hsvS->setChecked(false);
@@ -599,6 +614,9 @@ void KisColorSelectorSettings::loadDefaultPreferences()
     ui->csl_hsyH->setChecked(false);
     ui->csl_hsyS->setChecked(false);
     ui->csl_hsyY->setChecked(false);
+    ui->csl_hcgH->setChecked(false);
+    ui->csl_hcgC->setChecked(false);
+    ui->csl_hcgG->setChecked(false);

     //hotkeys//
     ui->sb_lightness->setValue(10);
diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_simple.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_simple.cpp
index aebd1f2..5ff757d 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_simple.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_simple.cpp
@@ -49,68 +49,83 @@ KoColor KisColorSelectorSimple::selectColor(int x, int y)

     switch (m_parameter) {
     case KisColorSelector::H:
-        emit paramChanged(relPos, -1, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(relPos, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hsvS:
-        emit paramChanged(-1, relPos, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, relPos, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hslS:
-        emit paramChanged(-1, -1, -1, relPos, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, relPos, -1, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsiS:
-        emit paramChanged(-1, -1, -1, -1, -1, relPos, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, relPos, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsyS:
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, relPos, -1);
-        break;
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, relPos, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgC:
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, relPos, -1);
+        break;
+    case KisColorSelector::hcgG:
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, relPos);
+        break;
     case KisColorSelector::V:
-        emit paramChanged(-1, -1, relPos, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, relPos, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::L:
-        emit paramChanged(-1, -1, -1, -1, relPos, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, relPos, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::I:
-        emit paramChanged(-1, -1, -1, -1, -1, -1, relPos, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, relPos, -1, -1, -1, -1);
         break;
 	case KisColorSelector::Y:
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, relPos);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, relPos, -1, -1);
+        break;
+    case KisColorSelector::hcgCG:
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, xRel, yRel);
         break;
     case KisColorSelector::SL:
-        emit paramChanged(-1, -1, -1, xRel, yRel, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, xRel, yRel, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::SI:
-        emit paramChanged(-1, -1, -1, -1, -1, xRel, yRel, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, xRel, yRel, -1, -1, -1, -1);
         break;
 	case KisColorSelector::SY:
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, xRel, yRel);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, xRel, yRel, -1, -1);
         break;
     case KisColorSelector::SV2:
     case KisColorSelector::SV:
-        emit paramChanged(-1, xRel, yRel, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, xRel, yRel, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hsvSH:
-        emit paramChanged(xRel, yRel, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(xRel, yRel, -1, -1, -1, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgCH:
+        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, -1, -1, yRel, -1);
         break;
     case KisColorSelector::hslSH:
-        emit paramChanged(xRel, -1, -1, yRel, -1, -1, -1, -1, -1);
+        emit paramChanged(xRel, -1, -1, yRel, -1, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsiSH:
-        emit paramChanged(xRel, -1, -1, -1, -1, yRel, -1, -1, -1);
+        emit paramChanged(xRel, -1, -1, -1, -1, yRel, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsySH:
-        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, yRel, -1);
+        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, yRel, -1, -1, -1);
         break;
     case KisColorSelector::VH:
-        emit paramChanged(xRel, -1, yRel, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(xRel, -1, yRel, -1, -1, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgGH:
+        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, -1, -1, -1, yRel);
         break;
     case KisColorSelector::LH:
-        emit paramChanged(xRel, -1, -1, -1, yRel, -1, -1, -1, -1);
+        emit paramChanged(xRel, -1, -1, -1, yRel, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::IH:
-        emit paramChanged(xRel, -1, -1, -1, -1, -1, yRel, -1, -1);
+        emit paramChanged(xRel, -1, -1, -1, -1, -1, yRel, -1, -1, -1, -1);
         break;
 	case KisColorSelector::YH:
-        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, -1, yRel);
+        emit paramChanged(xRel, -1, -1, -1, -1, -1, -1, -1, yRel, -1, -1);
         break;
     }

@@ -124,6 +139,7 @@ void KisColorSelectorSimple::setColor(const KoColor &color)
     qreal hslH, hslS, hslL;
 	qreal hsiH, hsiS, hsiI;
 	qreal hsyH, hsyS, hsyY;
+    qreal hcgH, hcgC, hcgG;
     KConfigGroup cfg =  KSharedConfig::openConfig()->group("advancedColorSelector");
     R = cfg.readEntry("lumaR", 0.2126);
     G = cfg.readEntry("lumaG", 0.7152);
@@ -134,36 +150,43 @@ void KisColorSelectorSimple::setColor(const KoColor &color)
     //here we add our convertor options
     m_parent->converter()->getHsiF(color, &hsiH, &hsiS, &hsiI);
     m_parent->converter()->getHsyF(color, &hsyH, &hsyS, &hsyY, R, G, B, Gamma);
+    m_parent->converter()->getHcgF(color, &hcgH, &hcgC, &hcgG);

 	//workaround, for some reason the HSI and HSY algorithms are fine, but they don't seem to update the selectors properly.
 	hsiH=hslH;
 	hsyH=hslH;
+    hcgH=hslH;

     switch (m_parameter) {
     case KisColorSelector::SL:
         m_lastClickPos.setX(hslS);
         m_lastClickPos.setY(1 - hslL);
-        emit paramChanged(-1, -1, -1, hslS, hslL, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, hslS, hslL, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgCG:
+        m_lastClickPos.setX(hcgC);
+        m_lastClickPos.setY(1 - hcgG);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, hcgC, hcgG);
         break;
 	case KisColorSelector::SI:
         m_lastClickPos.setX(hsiS);
         m_lastClickPos.setY(1 - hsiI);
-        emit paramChanged(-1, -1, -1, -1, -1, hsiS, hsiI, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, hsiS, hsiI, -1, -1, -1, -1);
         break;
 	case KisColorSelector::SY:
         m_lastClickPos.setX(hsyS);
         m_lastClickPos.setY(1 - hsyY);
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, hsyS, hsyY);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, hsyS, hsyY, -1, -1);
         break;
     case KisColorSelector::LH:
         m_lastClickPos.setX(qBound<qreal>(0., hslH, 1.));
         m_lastClickPos.setY(1 - hslL);
-        emit paramChanged(hslH, -1, -1, -1, hslL, -1, -1, -1, -1);
+        emit paramChanged(hslH, -1, -1, -1, hslL, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::SV:
         m_lastClickPos.setX(hsvS);
         m_lastClickPos.setY(1 - hsvV);
-        emit paramChanged(-1, hsvS, hsvV, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, hsvS, hsvV, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::SV2: {
         qreal xRel = hsvS;
@@ -174,81 +197,99 @@ void KisColorSelectorSimple::setColor(const KoColor &color)

         m_lastClickPos.setX(xRel);
         m_lastClickPos.setY(yRel);
-        emit paramChanged(-1, -1, -1, xRel, yRel, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, xRel, yRel, -1, -1, -1, -1, -1, -1);
         break;
     }
     case KisColorSelector::VH:
         m_lastClickPos.setX(qBound<qreal>(0., hsvH, 1.));
         m_lastClickPos.setY(1 - hsvV);
-        emit paramChanged(hsvH, -1, hsvV, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(hsvH, -1, hsvV, -1, -1, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgGH:
+        m_lastClickPos.setX(qBound<qreal>(0., hcgH, 1.));
+        m_lastClickPos.setY(1 - hcgG);
+        emit paramChanged(hcgH, -1, -1, -1, -1, -1, -1, -1, -1, -1, hcgG);
         break;
 	case KisColorSelector::IH:
         m_lastClickPos.setX(qBound<qreal>(0., hsiH, 1.));
         m_lastClickPos.setY(1 - hsiI);
-        emit paramChanged(hsiH, -1, -1, -1, -1, -1, hsiI, -1, -1);
+        emit paramChanged(hsiH, -1, -1, -1, -1, -1, hsiI, -1, -1, -1, -1);
         break;
 	case KisColorSelector::YH:
         m_lastClickPos.setX(qBound<qreal>(0., hsyH, 1.));
         m_lastClickPos.setY(1 - hsyY);
-        emit paramChanged(hsyH, -1, -1, -1, -1, -1, -1, -1, hsyY);
+        emit paramChanged(hsyH, -1, -1, -1, -1, -1, -1, -1, hsyY, -1, -1);
         break;
     case KisColorSelector::hsvSH:
         m_lastClickPos.setX(qBound<qreal>(0., hsvH, 1.));
         m_lastClickPos.setY(1 - hsvS);
-        emit paramChanged(hsvH, hsvS, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(hsvH, hsvS, -1, -1, -1, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgCH:
+        m_lastClickPos.setX(qBound<qreal>(0., hcgH, 1.));
+        m_lastClickPos.setY(1 - hcgC);
+        emit paramChanged(hcgH, -1, -1, -1, -1, -1, -1, -1, -1, hcgC, -1);
         break;
     case KisColorSelector::hslSH:
         m_lastClickPos.setX(qBound<qreal>(0., hslH, 1.));
         m_lastClickPos.setY(1 - hslS);
-        emit paramChanged(hslH, -1, -1, hslS, -1, -1, -1, -1, -1);
+        emit paramChanged(hslH, -1, -1, hslS, -1, -1, -1, -1, -1, -1, -1);
         break;
-
+
     case KisColorSelector::hsiSH:
         m_lastClickPos.setX(qBound<qreal>(0., hsiH, 1.));
         m_lastClickPos.setY(1 - hsiS);
-        emit paramChanged(hsiH, -1, -1, hsiS, -1, -1, -1, -1, -1);
+        emit paramChanged(hsiH, -1, -1, hsiS, -1, -1, -1, -1, -1, -1, -1);
         break;
-
+
     case KisColorSelector::hsySH:
         m_lastClickPos.setX(qBound<qreal>(0., hsyH, 1.));
         m_lastClickPos.setY(1 - hsyS);
-        emit paramChanged(hsyH, -1, -1, hsyS, -1, -1, -1, -1, -1);
+        emit paramChanged(hsyH, -1, -1, hsyS, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::L:
         m_lastClickPos.setX(qBound<qreal>(0., hslL, 1.));
-        emit paramChanged(-1, -1, -1, -1, hslL, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, hslL, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::I:
         m_lastClickPos.setX(qBound<qreal>(0., hsiI, 1.));
-        emit paramChanged(-1, -1, -1, -1, -1, -1, hsiI, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, hsiI, -1, -1, -1, -1);
         break;
     case KisColorSelector::V:
         m_lastClickPos.setX(hsvV);
-        emit paramChanged(-1, -1, hsvV, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, hsvV, -1, -1, -1, -1, -1, -1, -1, -1);
+        break;
+    case KisColorSelector::hcgG:
+        m_lastClickPos.setX(hcgG);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, hcgG);
+        break;
+    case KisColorSelector::hcgC:
+        m_lastClickPos.setX(hcgC);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, -1, hcgC, -1);
         break;
 	case KisColorSelector::Y:
         m_lastClickPos.setX(qBound<qreal>(0., hsyY, 1.));
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, hsyY);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, -1, hsyY, -1, -1);
         break;
     case KisColorSelector::hsvS:
         m_lastClickPos.setX( hsvS );
-        emit paramChanged(-1, hsvS, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, hsvS, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hslS:
         m_lastClickPos.setX( hslS );
-        emit paramChanged(-1, -1, -1, hslS, -1, -1, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, hslS, -1, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsiS:
         m_lastClickPos.setX( hsiS );
-        emit paramChanged(-1, -1, -1, -1, -1, hsiS, -1, -1, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, hsiS, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsyS:
         m_lastClickPos.setX( hsyS );
-        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, hsyS, -1);
+        emit paramChanged(-1, -1, -1, -1, -1, -1, -1, hsyS, -1, -1, -1);
         break;
     case KisColorSelector::H:
         m_lastClickPos.setX(qBound<qreal>(0., hsvH, 1.));
-        emit paramChanged(hsvH, -1, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(hsvH, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     default:
         Q_ASSERT(false);
@@ -290,6 +331,8 @@ void KisColorSelectorSimple::paint(QPainter* painter)
         case KisColorSelector::L:
 		case KisColorSelector::I:
 		case KisColorSelector::Y:
+        case KisColorSelector::hcgC:
+        case KisColorSelector::hcgG:
             if(width()>height()) {
                 painter->setPen(QColor(0,0,0));
                 painter->drawLine(m_lastClickPos.x()*width()-1, 0, m_lastClickPos.x()*width()-1, height());
@@ -303,6 +346,7 @@ void KisColorSelectorSimple::paint(QPainter* painter)
                 painter->drawLine(0, m_lastClickPos.x()*height()+1, width(), m_lastClickPos.x()*height()+1);
             }
             break;
+
         case KisColorSelector::SL:
         case KisColorSelector::SV:
         case KisColorSelector::SV2:
@@ -316,6 +360,9 @@ void KisColorSelectorSimple::paint(QPainter* painter)
         case KisColorSelector::LH:
 		case KisColorSelector::IH:
 		case KisColorSelector::YH:
+        case KisColorSelector::hcgGH:
+        case KisColorSelector::hcgCH:
+        case KisColorSelector::hcgCG:
             painter->setPen(QColor(0,0,0));
             painter->drawEllipse(m_lastClickPos.x()*width()-5, m_lastClickPos.y()*height()-5, 10, 10);
             painter->setPen(QColor(255,255,255));
@@ -339,6 +386,10 @@ KoColor KisColorSelectorSimple::colorAt(int x, int y)
     KoColor color(Qt::transparent, m_parent->colorSpace());

     switch(m_parameter) {
+
+    case KisColorSelector::hcgCG:
+        color = m_parent->converter()->fromHcgF(m_hue, xRel, yRel);
+        break;
     case KisColorSelector::SL:
         color = m_parent->converter()->fromHslF(m_hue, xRel, yRel);
         break;
@@ -354,6 +405,9 @@ KoColor KisColorSelectorSimple::colorAt(int x, int y)
 	case KisColorSelector::SY:
         color = m_parent->converter()->fromHsyF(m_hue, xRel, yRel, R, G, B, Gamma);
         break;
+    case KisColorSelector::hcgCH:
+        color = m_parent->converter()->fromHcgF(xRel, yRel, m_gray);
+        break;
     case KisColorSelector::hsvSH:
         color = m_parent->converter()->fromHsvF(xRel, yRel, m_value);
         break;
@@ -366,6 +420,9 @@ KoColor KisColorSelectorSimple::colorAt(int x, int y)
 	case KisColorSelector::hsySH:
         color = m_parent->converter()->fromHsyF(xRel, yRel, m_luma, R, G, B, Gamma);
         break;
+    case KisColorSelector::hcgGH:
+        color = m_parent->converter()->fromHcgF(xRel, m_hcgChroma, yRel);
+        break;
     case KisColorSelector::VH:
         color = m_parent->converter()->fromHsvF(xRel, m_hsvSaturation, yRel);
         break;
@@ -405,6 +462,12 @@ KoColor KisColorSelectorSimple::colorAt(int x, int y)
 	case KisColorSelector::Y:
         color = m_parent->converter()->fromHsyF(m_hue, m_hsySaturation, relPos, R, G, B, Gamma);
         break;
+    case KisColorSelector::hcgC:
+        color = m_parent->converter()->fromHcgF(m_hue, relPos, m_gray);
+        break;
+    case KisColorSelector::hcgG:
+        color = m_parent->converter()->fromHcgF(m_hue, m_hcgChroma, relPos);
+        break;
     default:
         Q_ASSERT(false);

diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_triangle.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_triangle.cpp
index b7170f7..6928594 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_triangle.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_triangle.cpp
@@ -134,7 +134,7 @@ void KisColorSelectorTriangle::setColor(const KoColor &color)
     // Workaround for Bug 287001
     setLastMousePosition(tmp.x(), tmp.y());

-    emit paramChanged(-1, s, v, -1, -1, -1, -1, -1, -1);
+    emit paramChanged(-1, s, v, -1, -1, -1, -1, -1, -1, -1, -1);
     emit update();
 }

diff --git a/plugins/dockers/advancedcolorselector/kis_color_selector_wheel.cpp b/plugins/dockers/advancedcolorselector/kis_color_selector_wheel.cpp
index 5866b87..8652553 100644
--- a/plugins/dockers/advancedcolorselector/kis_color_selector_wheel.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_color_selector_wheel.cpp
@@ -53,28 +53,34 @@ KoColor KisColorSelectorWheel::selectColor(int x, int y)

     switch (m_parameter) {
     case KisColorSelector::hsvSH:
-        emit paramChanged(angle, radius, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(angle, radius, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hslSH:
-        emit paramChanged(angle, -1, -1, radius, -1, -1, -1, -1, -1);
+        emit paramChanged(angle, -1, -1, radius, -1, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::hsiSH:
-        emit paramChanged(angle, -1, -1, -1, -1, radius, -1, -1, -1);
+        emit paramChanged(angle, -1, -1, -1, -1, radius, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::hsySH:
-        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, radius, -1);
+        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, radius, -1, -1, -1);
         break;
     case KisColorSelector::VH:
-        emit paramChanged(angle, -1, radius, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(angle, -1, radius, -1, -1, -1, -1, -1, -1, -1, -1);
         break;
     case KisColorSelector::LH:
-        emit paramChanged(angle, -1, -1, -1, radius, -1, -1, -1, -1);
+        emit paramChanged(angle, -1, -1, -1, radius, -1, -1, -1, -1, -1, -1);
         break;
 	case KisColorSelector::IH:
-        emit paramChanged(angle, -1, -1, -1, -1, -1, radius, -1, -1);
+        emit paramChanged(angle, -1, -1, -1, -1, -1, radius, -1, -1, -1, -1);
         break;
     case KisColorSelector::YH:
-        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, -1, radius);
+        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, -1, radius, -1, -1);
+        break;
+    case KisColorSelector::hcgCH:
+        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, -1, -1, radius, -1);
+        break;
+    case KisColorSelector::hcgGH:
+        emit paramChanged(angle, -1, -1, -1, -1, -1, -1, -1, -1, -1, radius);
         break;
     default:
         Q_ASSERT(false);
@@ -98,6 +104,7 @@ void KisColorSelectorWheel::setColor(const KoColor &color)
     qreal hslH, hslS, hslL;
 	qreal hsiH, hsiS, hsiI;
 	qreal hsyH, hsyS, hsyY;
+    qreal hcgH, hcgC, hcgG;
 	KConfigGroup cfg =  KSharedConfig::openConfig()->group("advancedColorSelector");
 	R = cfg.readEntry("lumaR", 0.2126);
     G = cfg.readEntry("lumaG", 0.7152);
@@ -107,10 +114,12 @@ void KisColorSelectorWheel::setColor(const KoColor &color)
     m_parent->converter()->getHslF(color, &hslH, &hslS, &hslL);
     m_parent->converter()->getHsiF(color, &hsiH, &hsiS, &hsiI);
     m_parent->converter()->getHsyF(color, &hsyH, &hsyS, &hsyY, R, G, B, Gamma);
+    m_parent->converter()->getHcgF(color, &hcgH, &hcgC, &hcgG);

 	//workaround, for some reason the HSI and HSY algorithms are fine, but they don't seem to update the selectors properly.
 	hsiH=hslH;
 	hsyH=hslH;
+    hcgH=hslH;

     qreal angle = 0.0, radius = 0.0;
     angle = hsvH;
@@ -118,37 +127,47 @@ void KisColorSelectorWheel::setColor(const KoColor &color)
     angle -= M_PI;
     switch (m_parameter) {
     case KisColorSelector::LH:
-        emit paramChanged(hslH, -1, -1, -1, hslL, -1, -1, -1, -1);
+        emit paramChanged(hslH, -1, -1, -1, hslL, -1, -1, -1, -1, -1, -1);
         radius = hslL;
         break;
     case KisColorSelector::VH:
-        emit paramChanged(hsvH, -1, hsvV, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(hsvH, -1, hsvV, -1, -1, -1, -1, -1, -1, -1, -1);
         radius = hsvV;
         break;
 	case KisColorSelector::IH:
-        emit paramChanged(hslH, -1, -1, -1, -1, -1, hsiI, -1, -1);
+        emit paramChanged(hslH, -1, -1, -1, -1, -1, hsiI, -1, -1, -1, -1);
         radius = hsiI;
         break;
     case KisColorSelector::YH:
-        emit paramChanged(hsvH, -1, -1, -1, -1, -1, -1, -1, hsyY);
+        emit paramChanged(hsvH, -1, -1, -1, -1, -1, -1, -1, hsyY, -1, -1);
         radius = hsyY;
         break;
     case KisColorSelector::hsvSH:
-        emit paramChanged(hsvH, hsvS, -1, -1, -1, -1, -1, -1, -1);
+        emit paramChanged(hsvH, hsvS, -1, -1, -1, -1, -1, -1, -1, -1, -1);
         radius = hsvS;
         break;
     case KisColorSelector::hslSH:
-        emit paramChanged(hslH, -1, -1, hslS, -1, -1, -1, -1, -1);
+        emit paramChanged(hslH, -1, -1, hslS, -1, -1, -1, -1, -1, -1, -1);
         radius = hslS;
         break;
 	case KisColorSelector::hsiSH:
-        emit paramChanged(hsiH, -1, -1, -1, -1, hsiS, -1, -1, -1);
+        emit paramChanged(hsiH, -1, -1, -1, -1, hsiS, -1, -1, -1, -1, -1);
         radius = hsiS;
         break;
     case KisColorSelector::hsySH:
-        emit paramChanged(hsyH, -1, -1, -1, -1, -1, -1, hsyS, -1);
+        emit paramChanged(hsyH, -1, -1, -1, -1, -1, -1, hsyS, -1, -1, -1);
         radius = hsyS;
         break;
+
+    case KisColorSelector::hcgGH:
+        emit paramChanged(hcgH, -1, -1, -1, -1, -1, -1, -1, -1, -1, hcgG);
+        radius = hcgG;
+        break;
+    case KisColorSelector::hcgCH:
+        emit paramChanged(hcgH, -1, -1, -1, -1, -1, -1, -1, -1, hcgC, -1);
+        radius = hcgC;
+        break;
+
     default:
         Q_ASSERT(false);
         break;
@@ -195,7 +214,7 @@ void KisColorSelectorWheel::paint(QPainter* painter)
     painter->drawImage(m_pixelCacheOffset.x(),m_pixelCacheOffset.y(), m_pixelCache);

     // draw blips
-
+
     if(m_lastClickPos!=QPoint(-1,-1) && m_parent->displayBlip()) {
         QPoint pos = (m_lastClickPos*qMin(width(), height())).toPoint();
         if(width()<height())
@@ -259,6 +278,13 @@ KoColor KisColorSelectorWheel::colorAt(int x, int y, bool forceValid)
 	case KisColorSelector::YH:
         color = m_parent->converter()->fromHsyF(angle, m_hsySaturation, radius, R, G, B, Gamma);
         break;
+
+    case KisColorSelector::hcgCH:
+        color = m_parent->converter()->fromHcgF(angle, radius, m_gray);
+        break;
+    case KisColorSelector::hcgGH:
+        color = m_parent->converter()->fromHcgF(angle, m_hcgChroma, radius);
+        break;
     default:
         Q_ASSERT(false);

diff --git a/plugins/dockers/advancedcolorselector/kis_my_paint_shade_selector.cpp b/plugins/dockers/advancedcolorselector/kis_my_paint_shade_selector.cpp
index f67953a..8ab1863 100644
--- a/plugins/dockers/advancedcolorselector/kis_my_paint_shade_selector.cpp
+++ b/plugins/dockers/advancedcolorselector/kis_my_paint_shade_selector.cpp
@@ -158,9 +158,10 @@ void KisMyPaintShadeSelector::paintEvent(QPaintEvent *) {
 					KoColor color;
                     //KoColor color = converter()->fromHsvF(fh, fs, fv);
 					if(shadeMyPaintType=="HSV"){color = converter()->fromHsvF(fh, fs, fv);}
-					else if(shadeMyPaintType=="HSL"){color = converter()->fromHslF(fh, fs, fv);}
-					else if(shadeMyPaintType=="HSI"){color = converter()->fromHsiF(fh, fs, fv);}
+					else if(shadeMyPaintType=="HSL"){color = converter()->fromHslF(fh, fs, fv);}
+					else if(shadeMyPaintType=="HSI"){color = converter()->fromHsiF(fh, fs, fv);}
 					else if(shadeMyPaintType=="HSY"){color = converter()->fromHsyF(fh, fs, fv, R, G, B);}
+                    else if(shadeMyPaintType=="HCG"){color = converter()->fromHcgF(fh, fs, fv);}
 					else{dbgKrita<<"MyPaint Color selector don't work right.";
 					color = converter()->fromHsvF(fh, fs, fv);}
 //dbgKrita<<color->toQcolor();
@@ -187,9 +188,10 @@ void KisMyPaintShadeSelector::paintEvent(QPaintEvent *) {
 			KoColor color;
             //KoColor color = converter()->fromHsvF(fh, fs, fv);
 			if(shadeMyPaintType=="HSV"){color = converter()->fromHsvF(fh, fs, fv);}
-			else if(shadeMyPaintType=="HSL"){color = converter()->fromHslF(fh, fs, fv);}
-			else if(shadeMyPaintType=="HSI"){color = converter()->fromHsiF(fh, fs, fv);}
+			else if(shadeMyPaintType=="HSL"){color = converter()->fromHslF(fh, fs, fv);}
+			else if(shadeMyPaintType=="HSI"){color = converter()->fromHsiF(fh, fs, fv);}
 			else if(shadeMyPaintType=="HSY"){color = converter()->fromHsyF(fh, fs, fv);}
+            else if(shadeMyPaintType=="HCG"){color = converter()->fromHcgF(fh, fs, fv);}
 			else{dbgKrita<<"MyPaint Color selector don't work right.";
 			color = converter()->fromHsvF(fh, fs, fv);}

@@ -263,9 +265,10 @@ void KisMyPaintShadeSelector::setColor(const KoColor &color) {
     B = cfg.readEntry("lumaB", 0.0722);

 	if(shadeMyPaintType=="HSV"){this->converter()->getHsvF(color, &m_colorH, &m_colorS, &m_colorV);}
-	if(shadeMyPaintType=="HSL"){this->converter()->getHslF(color, &m_colorH, &m_colorS, &m_colorV);}
-	if(shadeMyPaintType=="HSI"){this->converter()->getHsiF(color, &m_colorH, &m_colorS, &m_colorV);}
+	if(shadeMyPaintType=="HSL"){this->converter()->getHslF(color, &m_colorH, &m_colorS, &m_colorV);}
+	if(shadeMyPaintType=="HSI"){this->converter()->getHsiF(color, &m_colorH, &m_colorS, &m_colorV);}
 	if(shadeMyPaintType=="HSY"){this->converter()->getHsyF(color, &m_colorH, &m_colorS, &m_colorV, R, G, B);}
+    if(shadeMyPaintType=="HCG"){this->converter()->getHcgF(color, &m_colorH, &m_colorS, &m_colorV);}
     m_lastRealColor = color;
     this->updateColorPreview(color);

diff --git a/plugins/dockers/advancedcolorselector/wdg_color_selector_settings.ui b/plugins/dockers/advancedcolorselector/wdg_color_selector_settings.ui
index e105b5a..2a83b0d 100644
--- a/plugins/dockers/advancedcolorselector/wdg_color_selector_settings.ui
+++ b/plugins/dockers/advancedcolorselector/wdg_color_selector_settings.ui
@@ -1272,6 +1272,51 @@
         </layout>
        </widget>
       </item>
+      <item>
+       <widget class="QGroupBox" name="groupHcg">
+        <property name="title">
+         <string>HCG Sliders to Show</string>
+        </property>
+        <layout class="QHBoxLayout" name="horizontalLayout_10">
+         <property name="leftMargin">
+          <number>9</number>
+         </property>
+         <property name="topMargin">
+          <number>9</number>
+         </property>
+         <property name="rightMargin">
+          <number>9</number>
+         </property>
+         <property name="bottomMargin">
+          <number>9</number>
+         </property>
+         <item>
+          <widget class="QCheckBox" name="csl_hcgH">
+           <property name="text">
+            <string>Hue</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="csl_hcgC">
+           <property name="text">
+            <string>Chroma</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QCheckBox" name="csl_hcgG">
+           <property name="text">
+            <string>Gray</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
+        <zorder>csl_hcgC</zorder>
+        <zorder>csl_hcgH</zorder>
+        <zorder>csl_hcgG</zorder>
+       </widget>
+      </item>
      </layout>
     </widget>
    </item>
diff --git a/plugins/dockers/colorslider/kis_color_slider_dock.cpp b/plugins/dockers/colorslider/kis_color_slider_dock.cpp
index e2f1519..41120c0 100644
--- a/plugins/dockers/colorslider/kis_color_slider_dock.cpp
+++ b/plugins/dockers/colorslider/kis_color_slider_dock.cpp
@@ -75,7 +75,7 @@ void ColorSliderDock::setCanvas(KoCanvasBase * canvas)
         //m_updateAllowed = true;

         //settings//
-        QBitArray m_SlidersConfigArray(12);
+        QBitArray m_SlidersConfigArray(15);

         KConfigGroup cfg =  KSharedConfig::openConfig()->group("hsxColorSlider");

@@ -95,6 +95,9 @@ void ColorSliderDock::setCanvas(KoCanvasBase * canvas)
         m_SlidersConfigArray[10]=cfg.readEntry("hsyS", false);
         m_SlidersConfigArray[11]=cfg.readEntry("hsyY", false);

+        m_SlidersConfigArray[12] =cfg.readEntry("hcgH", false);
+        m_SlidersConfigArray[13] =cfg.readEntry("hcgC", false);
+        m_SlidersConfigArray[14] =cfg.readEntry("hcgG", false);

         m_colorSliders = new KisColorSliderWidget(kisCanvas->displayColorConverter()->displayRendererInterface(), this, kisCanvas, m_SlidersConfigArray);
         m_layout->addWidget(m_colorSliders);
diff --git a/plugins/dockers/colorslider/kis_color_slider_input.cpp b/plugins/dockers/colorslider/kis_color_slider_input.cpp
index 8e0a460..ec738b1 100644
--- a/plugins/dockers/colorslider/kis_color_slider_input.cpp
+++ b/plugins/dockers/colorslider/kis_color_slider_input.cpp
@@ -74,8 +74,11 @@ void KisColorSliderInput::init()
     case 9: m_name=i18n("Hue"); break;
     case 10: m_name=i18n("Saturation"); break;
     case 11: m_name=i18n("Luma"); break;
+    case 12: m_name=i18n("Hue"); break;
+    case 13: m_name=i18n("Chroma"); break;
+    case 14: m_name=i18n("Gray"); break;
     }
-
+
     QLabel* m_label = new QLabel(i18n("%1:", m_name), this);
     m_layout->addWidget(m_label);

@@ -174,6 +177,19 @@ void KisHSXColorSliderInput::setValue(double v)
             m_hueupdating=false;
         }
         break;
+    case 12:
+        m_hue = v;
+        h=m_hue/360.0f;
+        s=m_sat/100.0f;
+        l=m_val/100.0f;
+        *m_color = this->converter()->fromHcgF(h, s, l);
+        if (m_hueupdating==false) {
+            emit(hueUpdated(static_cast<int>(m_hue)));
+        }
+        else {
+            m_hueupdating=false;
+        }
+        break;
     case 1:
         m_sat = v;
         h=m_hue/360.0f;
@@ -278,6 +294,32 @@ void KisHSXColorSliderInput::setValue(double v)
             m_toneupdating=false;
         }
         break;
+    case 13:
+        m_sat = v;
+        h=m_hue/360.0f;
+        s=m_sat/100.0f;
+        l=m_val/100.0f;
+        *m_color = this->converter()->fromHcgF(h, s, l);
+        if (m_satupdating==false) {
+            emit(satUpdated(static_cast<int>(m_sat), m_type));
+        }
+        else {
+            m_satupdating=false;
+        }
+        break;
+    case 14:
+        m_val = v;
+        h=m_hue/360.0f;
+        s=m_sat/100.0f;
+        l=m_val/100.0f;
+        *m_color = this->converter()->fromHcgF(h, s, l);
+        if (m_toneupdating==false) {
+            emit(toneUpdated(static_cast<int>(m_val), m_type));
+        }
+        else {
+            m_toneupdating=false;
+        }
+        break;
     default:
         Q_ASSERT(false);
     }
@@ -286,16 +328,20 @@ void KisHSXColorSliderInput::setValue(double v)
 //update
 void KisHSXColorSliderInput::update()
 {
-
+
     KoColor min = *m_color;
     KoColor max = *m_color;
-
+
     qreal hue, sat, val, hue_backup, sat_backup, val_backup;
     //gets the hsv for the appropriate type//
     hue_backup = m_hue;
     sat_backup = m_sat;
     val_backup = m_val;
-
+
+    hue = m_hue / 360.0;
+    sat = m_sat * 0.01;
+    val = m_val * 0.01;
+
     switch (m_type) {
     case 0:
         this->converter()->getHsvF(*m_color, &hue, &sat, &val);
@@ -307,8 +353,8 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
             if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
@@ -326,11 +372,11 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
-
+
             if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
                 sat = (sat_backup*0.01);
             }
@@ -363,8 +409,8 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
             if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
@@ -382,11 +428,11 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
-
+
             if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
                 sat = (sat_backup*0.01);
             }
@@ -419,8 +465,8 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
             if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
@@ -438,11 +484,11 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
-
+
             if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
                 sat = (sat_backup*0.01);
             }
@@ -475,8 +521,8 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
             if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
@@ -494,11 +540,11 @@ void KisHSXColorSliderInput::update()
             if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
                 val = (val_backup*0.01);
             }
-
-
+
+
         }
         else{
-
+
             if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
                 sat = (sat_backup*0.01);
             }
@@ -521,35 +567,99 @@ void KisHSXColorSliderInput::update()
             }
         }
         break;
+
+    case 12:
+        this->converter()->getHcgF(*m_color, &hue, &sat, &val);
+        if (m_sliderisupdating==true)
+        {
+            if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
+                sat = (sat_backup*0.01);
+            }
+            if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
+                val = (val_backup*0.01);
+            }
+        }
+        else{
+            if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
+                hue = (hue_backup/360.0);
+            }
+        }
+        break;
+    case 13:
+        this->converter()->getHcgF(*m_color, &hue, &sat, &val);
+        if (m_sliderisupdating==true)
+        {
+            if( (hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2 ) {
+                hue = (hue_backup/360.0);
+            }
+            if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
+                val = (val_backup*0.01);
+            }
+        }
+        else{
+
+            if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
+                sat = (sat_backup*0.01);
+            }
+        }
+        break;
+    case 14:
+        this->converter()->getHcgF(*m_color, &hue, &sat, &val);
+        if (m_sliderisupdating==true)
+        {
+            if((sat*100.0)<m_sat+2 && (sat*100.0)>m_sat-2) {
+                sat = (sat_backup*0.01);
+            }
+            if((hue*360.0)<m_hue+2 && (hue*360.0)>m_hue-2) {
+                hue = (hue_backup/360.0);
+            }
+        }
+        else{
+            if((val*100.0)<m_val+2 && (val*100.0)>m_val-2) {
+                val = (val_backup*0.01);
+            }
+        }
+        break;
+
     }
-    //this prevents the hue going to 0 when used with grey//

-    if (sat<=0.0) {
+    if (sat<0.01) {
         m_hue = hue_backup;
     }
     else{
         m_hue=(hue*360.0);
     }

-    if (val==0 || val>0.999) {
-        m_sat = sat_backup;
-    }
-    else{
+    if(m_type < 12){
+        if (val<0.01 || val>0.99) {
+            m_sat = sat_backup;
+        }
+        else{
+            m_sat=(sat*100.0);
+        }
+        m_val=(val*100.0);
+    } else {
         m_sat=(sat*100.0);
+        if (sat>0.99) {
+            m_val = val_backup;
+        }
+        else{
+            m_val=(val*100.0);
+        }
     }

-    m_val=(val*100.0);

     if (m_hueupdating==true){m_val=val_backup; m_sat = sat_backup; m_hueupdating=false;}
     else if (m_satupdating==true){m_val=val_backup; m_hue = hue_backup; m_satupdating=false;}
     else if (m_toneupdating==true){m_sat=sat_backup; m_hue = hue_backup;m_toneupdating=false;}
-
+
     //sets slider and num-input according to type//
     switch (m_type) {
     case 0:
     case 3:
     case 6:
     case 9:
+    case 12:
         m_NumInput->setValue(m_hue);
         m_hsvSlider->setValue(static_cast<int>(m_hue));
         break;
@@ -585,10 +695,19 @@ void KisHSXColorSliderInput::update()
         m_NumInput->setValue(m_val);
         m_hsvSlider->setValue(static_cast<int>(m_val));
         break;
+    case 13:
+        m_NumInput->setValue(m_sat);
+        m_hsvSlider->setValue(static_cast<int>(m_sat));
+        break;
+    case 14:
+        m_NumInput->setValue(m_val);
+        m_hsvSlider->setValue(static_cast<int>(m_val));
+        break;
+
     default:
         Q_ASSERT(false);
     }
-    m_hsvSlider->setColors(*m_color,m_type, m_hue, R, G, B, Gamma);
+    m_hsvSlider->setColors(*m_color,m_type, m_hue, m_val, R, G, B, Gamma);
 }

 QWidget* KisHSXColorSliderInput::createInput()
@@ -603,6 +722,7 @@ QWidget* KisHSXColorSliderInput::createInput()
     case 3:
     case 6:
     case 9:
+    case 12:
         m_NumInput->setMaximum(360.0);
         m_NumInput->setWrapping(true);
         m_hsvSlider->setMaximum(360);
@@ -616,6 +736,8 @@ QWidget* KisHSXColorSliderInput::createInput()
     case 8:
     case 10:
     case 11:
+    case 13:
+    case 14:
         m_NumInput->setMaximum(100.0);
         m_hsvSlider->setMaximum(100);
         m_NumInput->setSingleStep (10.0);
@@ -688,7 +810,7 @@ void KisHSXColorSliderInput::toneUpdate(int l, int type)
     if (m_type==type-1 || m_type==type-2)
     {
         if (l<25 || l>75){
-
+
             if (l<=m_val-10 || l>=m_val+10) {
                 m_val=l;
                 m_toneupdating=true;
@@ -702,8 +824,8 @@ void KisHSXColorSliderInput::toneUpdate(int l, int type)
                 update();
             }
         }
-
-
+
+
     }
 }

diff --git a/plugins/dockers/colorslider/kis_color_slider_widget.cpp b/plugins/dockers/colorslider/kis_color_slider_widget.cpp
index 7367592..bdbecdc 100644
--- a/plugins/dockers/colorslider/kis_color_slider_widget.cpp
+++ b/plugins/dockers/colorslider/kis_color_slider_widget.cpp
@@ -53,25 +53,25 @@ KisColorSliderWidget::KisColorSliderWidget(KoColorDisplayRendererInterface *disp
     m_layout->setContentsMargins(0,0,0,0);
     m_layout->setSpacing(1);
     m_updateAllowed = true;
-
+
     connect(m_updateCompressor, SIGNAL(timeout()), SLOT(updateTimeout()));
     m_configCompressor = new KisSignalCompressor(10, KisSignalCompressor::POSTPONE, this);
     connect(m_configCompressor, SIGNAL(timeout()), SLOT(setConfig()));
     //dbgKrita<<"m_canvas:"<<m_canvas;
-
+
     m_inputs.clear();
-
+
     //this first creates and set the sliders.
     //then setslidervisible is called to make them visible and connect them.
     //This way they can also be disabled more easily.
-
+
     //hsv sliders//
-
+
     hsvH = new KisHSXColorSliderInput(this, 0, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsvH);
     m_layout->addWidget(hsvH);
     hsvH->setVisible(false);
-
+
     hsvS = new KisHSXColorSliderInput(this, 1, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsvS);
     m_layout->addWidget(hsvS);
@@ -81,9 +81,9 @@ KisColorSliderWidget::KisColorSliderWidget(KoColorDisplayRendererInterface *disp
     m_inputs.append(hsvV);
     m_layout->addWidget(hsvV);
     hsvV->setVisible(false);
-
+
     //hsl sliders//
-
+
     hslH = new KisHSXColorSliderInput(this, 3, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hslH);
     m_layout->addWidget(hslH);
@@ -93,51 +93,70 @@ KisColorSliderWidget::KisColorSliderWidget(KoColorDisplayRendererInterface *disp
     m_inputs.append(hslS);
     m_layout->addWidget(hslS);
     hslS->setVisible(false);
-
+
     hslL = new KisHSXColorSliderInput(this, 5, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hslL);
     m_layout->addWidget(hslL);
     hslL->setVisible(false);
-
-
+
+
     //hsi sliders//
-
+
     hsiH = new KisHSXColorSliderInput(this, 6, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsiH);
     m_layout->addWidget(hsiH);
     hsiH->setVisible(false);
-
+
     hsiS = new KisHSXColorSliderInput(this, 7, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsiS);
     m_layout->addWidget(hsiS);
     hsiS->setVisible(false);
-
+
     hsiI = new KisHSXColorSliderInput(this, 8, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsiI);
     m_layout->addWidget(hsiI);
     hsiI->setVisible(false);
-
+
     //hsy'sliders//
-
+
     hsyH = new KisHSXColorSliderInput(this, 9, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsyH);
     m_layout->addWidget(hsyH);
     hsyH->setVisible(false);
-
+
     hsyS = new KisHSXColorSliderInput(this, 10, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsyS);
     m_layout->addWidget(hsyS);
     hsyS->setVisible(false);
-
+
     hsyY = new KisHSXColorSliderInput(this, 11, &m_color, m_displayRenderer, m_canvas);
     m_inputs.append(hsyY);
     m_layout->addWidget(hsyY);
     hsyY->setVisible(false);

+
+
+    hcgH = new KisHSXColorSliderInput(this, 12, &m_color, m_displayRenderer, m_canvas);
+    m_inputs.append(hcgH);
+    m_layout->addWidget(hcgH);
+    hcgH->setVisible(false);
+
+    hcgC = new KisHSXColorSliderInput(this, 13, &m_color, m_displayRenderer, m_canvas);
+    m_inputs.append(hcgC);
+    m_layout->addWidget(hcgC);
+    hcgC->setVisible(false);
+
+    hcgG = new KisHSXColorSliderInput(this, 14, &m_color, m_displayRenderer, m_canvas);
+    m_inputs.append(hcgG);
+    m_layout->addWidget(hcgG);
+    hcgG->setVisible(false);
+
+
+
     m_layout->addStretch(1);

     setSlidersVisible(SlidersConfigArray);
-
+

 }

@@ -166,14 +185,14 @@ void KisColorSliderWidget::setColor(const KoColor& c)
 void KisColorSliderWidget::updateTimeout()
 {
     emit(colorChanged(m_color));
-
+
 }

 void KisColorSliderWidget::setSlidersVisible(QBitArray SlidersConfigArray)
 {
     //dbgKrita<<"check2";
     QList<KisColorSliderInput*> visibleInputs;
-
+
     if (SlidersConfigArray[0]==true) {
         visibleInputs.append(hsvH);
         hsvH->setVisible(true);
@@ -414,6 +433,69 @@ void KisColorSliderWidget::setSlidersVisible(QBitArray SlidersConfigArray)
         disconnect(hsyY, SIGNAL(toneUpdated(int, int)), this, SLOT(toneUpdate(int, int)));
     }

+
+    if (SlidersConfigArray[12]==true) {
+        visibleInputs.append(hcgH);
+        hcgH->setVisible(true);
+        connect(hcgH, SIGNAL(updated()), this, SLOT(update()));
+        connect(this, SIGNAL(updated()), hcgH, SLOT(update()));
+        connect(hcgH, SIGNAL(hueUpdated(int)), this, SLOT(hueUpdate(int)));
+        connect(this, SIGNAL(hueUpdated(int)), hcgH, SLOT(hueUpdate(int)));
+        connect(this, SIGNAL(satUpdated(int, int)), hcgH, SLOT(satUpdate(int, int)));
+        connect(this, SIGNAL(toneUpdated(int, int)), hcgH, SLOT(toneUpdate(int, int)));
+    }
+    else {
+        hcgH->setVisible(false);
+        disconnect(hcgH, SIGNAL(updated()), this, SLOT(update()));
+        disconnect(this, SIGNAL(updated()), hcgH, SLOT(update()));
+        disconnect(hcgH, SIGNAL(hueUpdated(int)), this, SLOT(hueUpdate(int)));
+        disconnect(this, SIGNAL(hueUpdated(int)), hcgH, SLOT(hueUpdate(int)));
+        disconnect(this, SIGNAL(satUpdated(int, int)), hcgH, SLOT(satUpdate(int, int)));
+        disconnect(this, SIGNAL(toneUpdated(int, int)), hcgH, SLOT(toneUpdate(int, int)));
+    }
+
+    if (SlidersConfigArray[13]==true) {
+        visibleInputs.append(hcgC);
+        hcgC->setVisible(true);
+        connect(hcgC, SIGNAL(updated()), this, SLOT(update()));
+        connect(this, SIGNAL(updated()), hcgC, SLOT(update()));
+        connect(this, SIGNAL(hueUpdated(int)), hcgC, SLOT(hueUpdate(int)));
+        connect(hcgC, SIGNAL(satUpdated(int, int)), this, SLOT(satUpdate(int, int)));
+        connect(this, SIGNAL(satUpdated(int, int)), hcgC, SLOT(satUpdate(int, int)));
+        connect(this, SIGNAL(toneUpdated(int, int)), hcgC, SLOT(toneUpdate(int, int)));
+    }
+    else {
+        hcgC->setVisible(false);
+        disconnect(hcgC, SIGNAL(updated()), this, SLOT(update()));
+        disconnect(this, SIGNAL(updated()), hcgC, SLOT(update()));
+        disconnect(this, SIGNAL(hueUpdated(int)), hcgC, SLOT(hueUpdate(int)));
+        disconnect(hcgC, SIGNAL(satUpdated(int, int)), this, SLOT(satUpdate(int, int)));
+        disconnect(this, SIGNAL(satUpdated(int, int)), hcgC, SLOT(satUpdate(int, int)));
+        disconnect(this, SIGNAL(toneUpdated(int, int)), hcgC, SLOT(toneUpdate(int, int)));
+    }
+
+    if (SlidersConfigArray[14]==true) {
+        visibleInputs.append(hcgG);
+        hcgG->setVisible(true);
+        connect(hcgG, SIGNAL(updated()), this, SLOT(update()));
+        connect(this, SIGNAL(updated()), hcgG, SLOT(update()));
+        connect(this, SIGNAL(hueUpdated(int)), hcgG, SLOT(hueUpdate(int)));
+        connect(this, SIGNAL(satUpdated(int, int)), hcgG, SLOT(satUpdate(int, int)));
+        connect(this, SIGNAL(toneUpdated(int, int)), hcgG, SLOT(toneUpdate(int, int)));
+        connect(hcgG, SIGNAL(toneUpdated(int, int)), this, SLOT(toneUpdate(int, int)));
+    }
+    else {
+        hcgG->setVisible(false);
+        disconnect(hcgG, SIGNAL(updated()), this, SLOT(update()));
+        disconnect(this, SIGNAL(updated()), hcgG, SLOT(update()));
+        disconnect(this, SIGNAL(hueUpdated(int)), hcgG, SLOT(hueUpdate(int)));
+        disconnect(this, SIGNAL(satUpdated(int, int)), hcgG, SLOT(satUpdate(int, int)));
+        disconnect(this, SIGNAL(toneUpdated(int, int)), hcgG, SLOT(toneUpdate(int, int)));
+        disconnect(hcgG, SIGNAL(toneUpdated(int, int)), this, SLOT(toneUpdate(int, int)));
+    }
+
+
+
     QList<QLabel*> labels;
     int labelWidth = 0;

@@ -442,28 +524,32 @@ void KisColorSliderWidget::setConfig()
 {
     //QTimer::singleShot(1, this, SLOT(update()));//need to wait a bit before accessing the config.

-    QBitArray m_SlidersConfigArray(12);
+    QBitArray m_SlidersConfigArray(15);
     //dbgKrita<<"check";
     KConfigGroup cfg =  KSharedConfig::openConfig()->group("hsxColorSlider");

     m_SlidersConfigArray[0] =cfg.readEntry("hsvH", false);
     m_SlidersConfigArray[1] =cfg.readEntry("hsvS", false);
     m_SlidersConfigArray[2] =cfg.readEntry("hsvV", false);
-
+
     m_SlidersConfigArray[3] =cfg.readEntry("hslH", true);
     m_SlidersConfigArray[4] =cfg.readEntry("hslS", true);
     m_SlidersConfigArray[5] =cfg.readEntry("hslL", true);
-
+
     m_SlidersConfigArray[6] =cfg.readEntry("hsiH", false);
     m_SlidersConfigArray[7] =cfg.readEntry("hsiS", false);
     m_SlidersConfigArray[8] =cfg.readEntry("hsiI", false);
-
+
     m_SlidersConfigArray[9] =cfg.readEntry("hsyH", false);
     m_SlidersConfigArray[10]=cfg.readEntry("hsyS", false);
     m_SlidersConfigArray[11]=cfg.readEntry("hsyY", false);
-
+
+    m_SlidersConfigArray[12]=cfg.readEntry("hcgH", false);
+    m_SlidersConfigArray[13]=cfg.readEntry("hcgC", false);
+    m_SlidersConfigArray[14]=cfg.readEntry("hcgG", false);
+
     setSlidersVisible(m_SlidersConfigArray);
-
+
 }

 void KisColorSliderWidget::hueUpdate(int h)
diff --git a/plugins/dockers/colorslider/kis_color_slider_widget.h b/plugins/dockers/colorslider/kis_color_slider_widget.h
index 92c7f33..1a837db 100644
--- a/plugins/dockers/colorslider/kis_color_slider_widget.h
+++ b/plugins/dockers/colorslider/kis_color_slider_widget.h
@@ -80,5 +80,8 @@ private:
     KisColorSliderInput* hsyH;
     KisColorSliderInput* hsyS;
     KisColorSliderInput* hsyY;
+    KisColorSliderInput* hcgH;
+    KisColorSliderInput* hcgC;
+    KisColorSliderInput* hcgG;
 };
 #endif
diff --git a/plugins/dockers/colorslider/kis_hsv_slider.cpp b/plugins/dockers/colorslider/kis_hsv_slider.cpp
index 9c925e8..9d8edce 100644
--- a/plugins/dockers/colorslider/kis_hsv_slider.cpp
+++ b/plugins/dockers/colorslider/kis_hsv_slider.cpp
@@ -39,6 +39,7 @@ struct KisHSVSlider::Private
     int HSVtype;
     KoColor minColor;
     qreal hue_b;
+    qreal val_b;
     QPixmap pixmap;
     bool upToDate;
     KoColorDisplayRendererInterface *displayRenderer;
@@ -70,12 +71,13 @@ KisHSVSlider::~KisHSVSlider()
 }


-void KisHSVSlider::setColors(const KoColor& currentc, const int type, qreal hue_backup, qreal l_R, qreal l_G, qreal l_B, qreal gamma)
+void KisHSVSlider::setColors(const KoColor& currentc, const int type, qreal hue_backup, qreal val_backup, qreal l_R, qreal l_G, qreal l_B, qreal gamma)
 {
     d->currentColorF = currentc;
     KoColor c = currentc;
     d->HSVtype = type;
     d->hue_b = hue_backup/360.0f;
+    d->val_b = val_backup/100.0f;
     R=l_R;
     G=l_G;
     B=l_B;
@@ -112,10 +114,10 @@ void KisHSVSlider::drawContents( QPainter *painter )

                 qreal t = static_cast<qreal>(x) / (contentsRect_.width() - 1);
                 t = 1.0-t;
-
+
                 //function find current color from hsv thingymabobs.
                 c = HSXcolor(type, t);
-
+
                 color = d->displayRenderer->toQColor(c);

                 for (int y = 0; y < contentsRect_.height(); y++)
@@ -126,14 +128,14 @@ void KisHSVSlider::drawContents( QPainter *painter )
             for (int y = 0; y < contentsRect_.height(); y++) {

                 qreal t = static_cast<qreal>(y) / (contentsRect_.height() - 1);
-
+
                 c = HSXcolor(type, t);
-
+
                 color = d->displayRenderer->toQColor(c);

                 for (int x = 0; x < contentsRect_.width(); x++)
                 image.setPixel(x, y, color.rgba());
-            }
+            }
         }
         d->pixmap = QPixmap::fromImage(image);
         d->upToDate = true;
@@ -156,6 +158,7 @@ KoColor KisHSVSlider::HSXcolor(int type, qreal t) const
     KoColor c = d->currentColorF;
     qreal hue, sat, val;
     qreal hue_backup = d->hue_b;
+    qreal val_backup = d->val_b;

     switch(type){
         case 0:
@@ -218,6 +221,26 @@ KoColor KisHSVSlider::HSXcolor(int type, qreal t) const
             this->converter()->getHsyF(c, &hue, &sat, &val, R, G, B, Gamma);
             coordinate_color = this->converter()->fromHsyF( hue, sat, (1.0 - t), R, G, B, Gamma);
             break;//hsy value
+
+        case 12:
+            this->converter()->getHcgF(c, &hue, &sat, &val);
+            coordinate_color = this->converter()->fromHcgF( (1.0 - t) , sat, val);
+            break;//hcg hue
+        case 13:
+            this->converter()->getHcgF(c, &hue, &sat, &val);
+            if (sat<0.001 && t<1.0) {
+                hue=hue_backup;
+            }
+            if (sat>0.999 && t>0.0) { //HCG specific
+                val=val_backup;
+            }
+            coordinate_color = this->converter()->fromHcgF( hue, (1.0 - t), val);
+            break;//hcg chroma
+        case 14:
+            this->converter()->getHcgF(c, &hue, &sat, &val);
+            coordinate_color = this->converter()->fromHcgF( hue, sat, (1.0 - t));
+            break;//hcg gray
+
         }
     return coordinate_color;
 }
diff --git a/plugins/dockers/colorslider/kis_hsv_slider.h b/plugins/dockers/colorslider/kis_hsv_slider.h
index 88db3a8..424a8f8 100644
--- a/plugins/dockers/colorslider/kis_hsv_slider.h
+++ b/plugins/dockers/colorslider/kis_hsv_slider.h
@@ -39,7 +39,7 @@ public:
     virtual ~KisHSVSlider();

 public:
-    void setColors( const KoColor& currentcolor, const int type, qreal hue_backup, qreal l_R=0.2126, qreal l_G=0.7152, qreal l_B=0.0722, qreal gamma=2.2);
+    void setColors( const KoColor& currentcolor, const int type, qreal hue_backup, qreal val_backup, qreal l_R=0.2126, qreal l_G=0.7152, qreal l_B=0.0722, qreal gamma=2.2);
     /**
      * Return the current color
      */
